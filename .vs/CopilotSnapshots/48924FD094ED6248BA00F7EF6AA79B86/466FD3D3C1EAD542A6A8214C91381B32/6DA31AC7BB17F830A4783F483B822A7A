using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.IO;

namespace ZastitaInformacija_18658
{
    public partial class Form1 : Form
    {
        private FileSystemWatcher fileSystemWatcher;
        private string teaKey = "1234567890abcdef"; // 16-byte key for TEA

        public Form1()
        {
            InitializeComponent();
            InitializeDefaultFolders();
        }

        private void InitializeDefaultFolders()
        {
            // Set default folders
            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            txtTargetFolder.Text = Path.Combine(desktopPath, "Target");
            txtOutputFolder.Text = Path.Combine(desktopPath, "X");
        }

        private void btnBrowseTarget_Click(object sender, EventArgs e)
        {
            if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
            {
                txtTargetFolder.Text = folderBrowserDialog.SelectedPath;
            }
        }

        private void btnBrowseOutput_Click(object sender, EventArgs e)
        {
            if (folderBrowserDialog.ShowDialog() == DialogResult.OK)
            {
                txtOutputFolder.Text = folderBrowserDialog.SelectedPath;
            }
        }

        private void btnStartMonitoring_Click(object sender, EventArgs e)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(txtTargetFolder.Text) || string.IsNullOrWhiteSpace(txtOutputFolder.Text))
                {
                    MessageBox.Show("Please specify both Target and Output folders.", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }

                // Create directories if they don't exist
                if (!Directory.Exists(txtTargetFolder.Text))
                    Directory.CreateDirectory(txtTargetFolder.Text);
                
                if (!Directory.Exists(txtOutputFolder.Text))
                    Directory.CreateDirectory(txtOutputFolder.Text);

                // Initialize FileSystemWatcher
                fileSystemWatcher = new FileSystemWatcher();
                fileSystemWatcher.Path = txtTargetFolder.Text;
                fileSystemWatcher.Filter = "*.*";
                fileSystemWatcher.NotifyFilter = NotifyFilters.CreationTime | NotifyFilters.FileName;
                fileSystemWatcher.Created += OnFileCreated;
                fileSystemWatcher.EnableRaisingEvents = true;

                btnStartMonitoring.Enabled = false;
                btnStopMonitoring.Enabled = true;

                AddStatusMessage($"Monitoring started for folder: {txtTargetFolder.Text}");
                AddStatusMessage($"Encrypted files will be saved to: {txtOutputFolder.Text}");
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error starting monitoring: {ex.Message}", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        private void btnStopMonitoring_Click(object sender, EventArgs e)
        {
            StopMonitoring();
        }

        private void StopMonitoring()
        {
            if (fileSystemWatcher != null)
            {
                fileSystemWatcher.EnableRaisingEvents = false;
                fileSystemWatcher.Dispose();
                fileSystemWatcher = null;
            }

            btnStartMonitoring.Enabled = true;
            btnStopMonitoring.Enabled = false;
            AddStatusMessage("Monitoring stopped.");
        }

        private void OnFileCreated(object sender, FileSystemEventArgs e)
        {
            try
            {
                // Wait a bit to ensure file is completely written
                System.Threading.Thread.Sleep(100);

                // Read the file
                byte[] fileContent = File.ReadAllBytes(e.FullPath);
                
                // Encrypt using TEA
                byte[] encryptedContent = TEAEncrypt(fileContent, teaKey);

                // Create output filename
                string originalFileName = Path.GetFileNameWithoutExtension(e.Name);
                string outputFileName = $"encrypted_{originalFileName}.txt";
                string outputPath = Path.Combine(txtOutputFolder.Text, outputFileName);

                // Save encrypted file
                File.WriteAllBytes(outputPath, encryptedContent);

                // Update status on UI thread
                Invoke(new Action(() =>
                {
                    AddStatusMessage($"File processed: {e.Name} -> {outputFileName}");
                }));
            }
            catch (Exception ex)
            {
                Invoke(new Action(() =>
                {
                    AddStatusMessage($"Error processing file {e.Name}: {ex.Message}");
                }));
            }
        }

        private void AddStatusMessage(string message)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            txtStatus.AppendText($"[{timestamp}] {message}\r\n");
            txtStatus.SelectionStart = txtStatus.Text.Length;
            txtStatus.ScrollToCaret();
        }

        private byte[] TEAEncrypt(byte[] data, string key)
        {
            // Convert key to 32-bit integers
            byte[] keyBytes = Encoding.UTF8.GetBytes(key);
            if (keyBytes.Length < 16)
            {
                Array.Resize(ref keyBytes, 16);
            }

            uint[] teaKey = new uint[4];
            for (int i = 0; i < 4; i++)
            {
                teaKey[i] = BitConverter.ToUInt32(keyBytes, i * 4);
            }

            // Pad data to multiple of 8 bytes
            int paddedLength = ((data.Length + 7) / 8) * 8;
            byte[] paddedData = new byte[paddedLength];
            Array.Copy(data, paddedData, data.Length);
            
            // Store original length at the beginning
            byte[] result = new byte[paddedLength + 4];
            BitConverter.GetBytes(data.Length).CopyTo(result, 0);

            // Encrypt in 8-byte blocks
            for (int i = 0; i < paddedLength; i += 8)
            {
                uint v0 = BitConverter.ToUInt32(paddedData, i);
                uint v1 = BitConverter.ToUInt32(paddedData, i + 4);
                
                uint sum = 0;
                uint delta = 0x9e3779b9;

                for (int j = 0; j < 32; j++)
                {
                    sum += delta;
                    v0 += ((v1 << 4) + teaKey[0]) ^ (v1 + sum) ^ ((v1 >> 5) + teaKey[1]);
                    v1 += ((v0 << 4) + teaKey[2]) ^ (v0 + sum) ^ ((v0 >> 5) + teaKey[3]);
                }

                BitConverter.GetBytes(v0).CopyTo(result, i + 4);
                BitConverter.GetBytes(v1).CopyTo(result, i + 8);
            }

            return result;
        }

        private void Form1_FormClosing(object sender, FormClosingEventArgs e)
        {
            StopMonitoring();
        }
    }
}
